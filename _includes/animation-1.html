<div>
    <div class="range-slider">
        <input class="rs_range" autocomplete="off" type="range" value="0.0" min="-5.0" max="5.0" step="0.01">
        <div class="rs_display">
            <p class="rs_p">$\mu_q$:&nbsp;</p>
            <p class="rs_value rs_p">0</p>
        </div>
    </div>
    <div class="range-slider">
        <input class="rs_range" autocomplete="off" type="range" value="1.0" min="1.0" max="5" step="0.01">
        <div class="rs_display">
            <p class="rs_p">$\sigma_q$:&nbsp;</p>
            <p class="rs_value rs_p">0</p>
        </div>
    </div>

    <button type="button" onclick="draw_samples_unif(1)">Generate 1</button>
    <button type="button" onclick="draw_samples_unif(10)">Generate 10</button>
    <button type="button" onclick="draw_samples_unif(100)">Generate 100</button>

    <div id="draw_here" style="text-align:center;"></div>
</div>

<style>
    .range-slider {
        display: flex; 
        align-items: center;
        margin-bottom: 8px;
    }
    .rs_range {
        width:35%;
        margin-right: 1em;
    }
    .rs_display {
        display: flex;
    }
    .rs_p {
        margin-top: 0px;
        margin-bottom: 0px;
    }
</style>

<script type="text/javascript">
    // Setup Sliders
    var rangeSlider = function(){
        var slider = $('.range-slider')
        slider.each(function(){
            var val = $(this).children().last().children().last()
            var range = $(this).children().first()

            val.html(range.attr('value'))            
            range.on('input', function(){
                $(this).next().children().last().html(this.value);
            });
        });
    };
    rangeSlider();

    // Compute Gaussian
    canvas = ({width:1000, height:500})
    margin = ({top: 20, right: 30, bottom: 30, left: 40})
    blue = "#4063d8"
    purple = "#9558b2"
    red = "#cb3c33"
    green = "#389826"

    l_blue = "#5073e8"
    l_red = "#db4c43"
    
    xlim = [-10, 10]
    ylim = [0.0, 0.5]

    mu = 0.0
    sigma = 1.0
    scale = 1.0 / Math.sqrt(2 * Math.PI * sigma**2)

    x_raw = d3.range(xlim[0], xlim[1], (xlim[1] - xlim[0]) / 1000)
    fx_gauss = Float64Array.from(x_raw, d => scale * Math.exp(-(((d - mu)**2)/(2 * sigma**2))))

    data = d3.transpose([x_raw, fx_gauss]).map(d => ({x: d[0], y: d[1]}))
    
    // Setup Chart
    x = d3.scaleLinear()
        .domain(d3.extent(data, d => d.x))
        .range([margin.left, canvas.width - margin.right])
    
    y=d3.scaleLinear()
        .domain(ylim)
        .range([canvas.height - margin.bottom, margin.top])
    
    xAxis = g => g
        .attr("transform", `translate(0,${canvas.height-margin.bottom})`)
        .call(d3.axisBottom(x).ticks(canvas.width / 80).tickSizeOuter(0))
    
    yAxis = g => g
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(canvas.height / 40))
    
    var svg = d3.select("div#draw_here").append("svg")
        .attr("viewBox", [0, 0, canvas.width, canvas.height]);
    
    // Draw q
    line = d3.line()
        .x(d => x(d.x))
        .y(d => y(d.y))

    svg.append("path")
        .attr("id", "p1")
        .attr("fill", "none")
        .attr("stroke", l_blue)
        .attr("stroke-width", 1.5)
        .attr("stroke-linejoin", "round")
        .attr("d", line(data));
    
    // Draw p
    line2 = d3.line()
        .x(d => x(d[0]))
        .y(d => y(d[1]))
    
    svg.append("path")
        .attr("id", "q1")
        .attr("fill", "none")
        .attr("stroke", l_red)
        .attr("stroke-width", 1.5)
        .attr("stroke-linejoin", "round")
        .attr("d", line2([
            [xlim[0], ylim[0]], [1, ylim[0]], [1, 0.2], [6, 0.2], [6, ylim[0]], [xlim[1], ylim[0]]
        ]));
    
    svg.append("g")
        .call(xAxis);

    svg.append("g")
        .call(yAxis);

    function transition() {
        mu = $(".rs_range")[0].value
        sigma = $(".rs_range")[1].value
        scale = 1.0 / Math.sqrt(2 * Math.PI * sigma**2)

        fx_gauss = Float64Array.from(x_raw, d => scale * Math.exp(-(((d - mu)**2)/(2 * sigma**2))))
        data = d3.transpose([x_raw, fx_gauss]).map(d => ({x: d[0], y: d[1]}))
        
        d3.select("path#p1")
            // .transition()
            // .duration(250)
            .attr("d", line(data))
    }

    d3.selectAll(".rs_range")
        .on("input", function() {transition()})
    
    // Generate Samples
    curr_sum = 0
    curr_count = 0

    function draw_samples_unif(n) {
        mu = $(".rs_range")[0].value
        sigma = $(".rs_range")[1].value

        samples = d3.range(n).map(function() {return d3.randomNormal(mu, sigma)();})

        scale = 1.0 / Math.sqrt(2 * Math.PI * sigma**2)
        fx_gauss = Float64Array.from(samples, d => scale * Math.exp(-(((d - mu)**2)/(2 * sigma**2))))
        fx_unif = Float64Array.from(samples, d => (d <= 6 & d >= 1) ? 0.2 : 0.0)

        
        for (i = 0; i < fx_gauss.length; i++) {
            // console.log(samples[i], fx_gauss[i], fx_unif[i], fx_unif[i] / fx_gauss[i])
            
            curr_sum += samples[i] * fx_unif[i] / fx_gauss[i]
            curr_count += fx_unif[i] / fx_gauss[i]

            svg.append("path")
                .attr("fill", "none")
                .attr("stroke", "#111")
                .attr("stroke-width", 0.5)
                .attr("stroke-linejoin", "round")
                .attr("d", line2([
                    [samples[i], ylim[0]], [samples[i], ylim[1]]
                ]));
            
        }

        console.log(curr_sum, curr_count, curr_sum / curr_count)
    }




    // thresholds = x.ticks(50)
    // density = kde(epanechnikov(1), thresholds, data)

    // xAxis = g => g
    //     .attr("transform", `translate(0,${height - margin.bottom})`)
    //     .call(d3.axisBottom(x))
    //     .call(g => g.append("text")
    //         .attr("x", width - margin.right)
    //         .attr("y", -6)
    //         .attr("fill", "#000")
    //         .attr("text-anchor", "end")
    //         .attr("font-weight", "bold")
    //         .text(data.title))
    
    // yAxis = g => g
    //     .attr("transform", `translate(${margin.left},0)`)
    //     .call(d3.axisLeft(y).ticks(null, "%"))
    //     .call(g => g.select(".domain").remove())


    // function kde(kernel, thresholds, data) {
    //     return thresholds.map(t => [t, d3.mean(data, d => kernel(t - d))]);
    // }
    // function epanechnikov(bandwidth) {
    //     return x => Math.abs(x /= bandwidth) <= 1 ? 0.75 * (1 - x * x) / bandwidth : 0;
    // }

    // line = d3.line()
    //     .curve(d3.curveBasis)
    //     .x(d => x(d[0]))
    //     .y(d => y(d[1]))
    
    // const promise = d3.json("/assets/faithful.json").then( function(data) {
    //     // console.log(data)

    //     height = 500
    //     width = 1000
    //     margin = ({top: 20, right: 30, bottom: 30, left: 40})

    //     x = d3.scaleLinear()
    //         .domain(d3.extent(data)).nice()
    //         .range([margin.left, width - margin.right])

    //     thresholds = x.ticks(50)




    //     density = kde(epanechnikov(1), thresholds, data)
    //     bins = d3.histogram()
    //             .domain(x.domain())
    //             .thresholds(thresholds)
    //         (data)

    //     y = d3.scaleLinear()
    //         .domain([0, d3.max(bins, d => d.length) / data.length])
    //         .range([height - margin.bottom, margin.top])
        
    //     xAxis = g => g
    //         .attr("transform", `translate(0,${height - margin.bottom})`)
    //         .call(d3.axisBottom(x))
    //         .call(g => g.append("text")
    //             .attr("x", width - margin.right)
    //             .attr("y", -6)
    //             .attr("fill", "#000")
    //             .attr("text-anchor", "end")
    //             .attr("font-weight", "bold")
    //             .text(data.title))
        
    //     yAxis = g => g
    //         .attr("transform", `translate(${margin.left},0)`)
    //         .call(d3.axisLeft(y).ticks(null, "%"))
    //         .call(g => g.select(".domain").remove())
        
    //     var svg = d3.select("div#draw_here").append("svg")
    //         .attr("viewBox", [0, 0, width, height]);
        
    //     // svg.append("g")
    //     //     .attr("fill", "#bbb")
    //     //     .selectAll("rect")
    //     //     .data(bins)
    //     //     .enter()
    //     //     .append("rect")
    //     //     .attr("x", d => x(d.x0) + 1)
    //     //     .attr("y", d => y(d.length / data.length))
    //     //     .attr("width", d => x(d.x1) - x(d.x0) - 1)
    //     //     .attr("height", d => y(0) - y(d.length / data.length));
                
    //     svg.append("path")
    //         .attr("id", "p1")
    //         .attr("fill", "none")
    //         .attr("stroke", "#000")
    //         .attr("stroke-width", 1.5)
    //         .attr("stroke-linejoin", "round")
    //         .attr("d", line(density));
        
    //     svg.append("g")
    //         .call(xAxis);

    //     svg.append("g")
    //         .call(yAxis);

    //     return data
    // });
    
</script>

