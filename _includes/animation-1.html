<div>
    <label for="vol">Volume (between 0 and 50):</label>
    <input type="submit" onclick="clicked()">
    <br/>

    <div class="range-slider">
        <input class="rs_range" autocomplete="off" type="range" value="0.01" min="0.01" max="5" step="0.01">
        <div class="rs_display">
            <p>$\sigma_p$:&nbsp;</p>
            <p class="rs_value">0</p>
        </div>
    </div>


    <div class="range-slider">
        <input class="rs_range" autocomplete="off" type="range" value="0.0" min="-5.0" max="5.0" step="0.01">
        <div class="rs_display">
            <p>$\mu_p$:&nbsp;</p>
            <p class="rs_value">0</p>
        </div>
    </div>


    <div id="draw_here" style="text-align:center;"></div>
</div>

<style>
    .range-slider {
        display: flex; 
        align-items: center;
    }
    .rs_range {
        width:35%;
        margin-right: 1em;
    }
    .rs_display {
        display: flex;
    }
</style>

<script type="text/javascript">
    // Setup sliders
    var rangeSlider = function(){
        var slider = $('.range-slider')
            // range = $('.rs_range'),
            // value = $('.rs_value');
        
        slider.each(function(){
            var val = $(this).children().last().children().last()
            var range = $(this).children().first()

            console.log(val, range)

            val.html(range.attr('value'))
        //     // value.each(function(){
        //     //     var value = $(this).parent().prev().attr('value');
        //     //     console.log(value)
        //     //     $(this).html(value);
        //     // });
            
            range.html(val.value);
            
            range.on('input', function(){
                $(this).next().children().last().html(this.value);
            });
        });
    };
    rangeSlider();


    // Gaussian
    xlim = [-10, 10]
    ylim = [0.0, 2.0]

    scale = 1.0
    sigma = 1.0
    mu = 0.0

    canvas = ({width:1000, height:500})
    margin = ({top: 20, right: 30, bottom: 30, left: 40})

    x_raw = d3.range(xlim[0], xlim[1], (xlim[1] - xlim[0]) / 1000)
    fx_gauss = Float64Array.from(x_raw, d => scale * Math.exp(-(((d - mu)**2)/(2 * sigma**2))))

    data = d3.transpose([x_raw, fx_gauss]).map(d => ({x: d[0], y: d[1]}))
    
    x = d3.scaleLinear()
        .domain(d3.extent(data, d => d.x))
        .range([margin.left, canvas.width - margin.right])
    
    y=d3.scaleLinear()
        .domain(ylim)
        .range([canvas.height - margin.bottom, margin.top])

    line = d3.line()
        .x(d => x(d.x))
        .y(d => y(d.y))
    
    xAxis = g => g
        .attr("transform", `translate(0,${canvas.height-margin.bottom})`)
        .call(d3.axisBottom(x).ticks(canvas.width / 80).tickSizeOuter(0))
    
    yAxis = g => g
        // .attr("transform", `translate(${canvas.width/2},0)`)
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(canvas.height / 40))
        
    line(data)

        
    var svg = d3.select("div#draw_here").append("svg")
        .attr("viewBox", [0, 0, canvas.width, canvas.height]);
    
    svg.append("path")
        .attr("id", "p1")
        .attr("fill", "none")
        .attr("stroke", "#000")
        .attr("stroke-width", 1.5)
        .attr("stroke-linejoin", "round")
        .attr("d", line(data));
    
    svg.append("g")
        .call(xAxis);

    svg.append("g")
        .call(yAxis);



    // thresholds = x.ticks(50)
    // density = kde(epanechnikov(1), thresholds, data)

    // xAxis = g => g
    //     .attr("transform", `translate(0,${height - margin.bottom})`)
    //     .call(d3.axisBottom(x))
    //     .call(g => g.append("text")
    //         .attr("x", width - margin.right)
    //         .attr("y", -6)
    //         .attr("fill", "#000")
    //         .attr("text-anchor", "end")
    //         .attr("font-weight", "bold")
    //         .text(data.title))
    
    // yAxis = g => g
    //     .attr("transform", `translate(${margin.left},0)`)
    //     .call(d3.axisLeft(y).ticks(null, "%"))
    //     .call(g => g.select(".domain").remove())




    // function kde(kernel, thresholds, data) {
    //     return thresholds.map(t => [t, d3.mean(data, d => kernel(t - d))]);
    // }
    // function epanechnikov(bandwidth) {
    //     return x => Math.abs(x /= bandwidth) <= 1 ? 0.75 * (1 - x * x) / bandwidth : 0;
    // }

    // line = d3.line()
    //     .curve(d3.curveBasis)
    //     .x(d => x(d[0]))
    //     .y(d => y(d[1]))
    
    // const promise = d3.json("/assets/faithful.json").then( function(data) {
    //     // console.log(data)

    //     height = 500
    //     width = 1000
    //     margin = ({top: 20, right: 30, bottom: 30, left: 40})

    //     x = d3.scaleLinear()
    //         .domain(d3.extent(data)).nice()
    //         .range([margin.left, width - margin.right])

    //     thresholds = x.ticks(50)




    //     density = kde(epanechnikov(1), thresholds, data)
    //     bins = d3.histogram()
    //             .domain(x.domain())
    //             .thresholds(thresholds)
    //         (data)

    //     y = d3.scaleLinear()
    //         .domain([0, d3.max(bins, d => d.length) / data.length])
    //         .range([height - margin.bottom, margin.top])
        
    //     xAxis = g => g
    //         .attr("transform", `translate(0,${height - margin.bottom})`)
    //         .call(d3.axisBottom(x))
    //         .call(g => g.append("text")
    //             .attr("x", width - margin.right)
    //             .attr("y", -6)
    //             .attr("fill", "#000")
    //             .attr("text-anchor", "end")
    //             .attr("font-weight", "bold")
    //             .text(data.title))
        
    //     yAxis = g => g
    //         .attr("transform", `translate(${margin.left},0)`)
    //         .call(d3.axisLeft(y).ticks(null, "%"))
    //         .call(g => g.select(".domain").remove())
        
    //     var svg = d3.select("div#draw_here").append("svg")
    //         .attr("viewBox", [0, 0, width, height]);
        
    //     // svg.append("g")
    //     //     .attr("fill", "#bbb")
    //     //     .selectAll("rect")
    //     //     .data(bins)
    //     //     .enter()
    //     //     .append("rect")
    //     //     .attr("x", d => x(d.x0) + 1)
    //     //     .attr("y", d => y(d.length / data.length))
    //     //     .attr("width", d => x(d.x1) - x(d.x0) - 1)
    //     //     .attr("height", d => y(0) - y(d.length / data.length));
                
    //     svg.append("path")
    //         .attr("id", "p1")
    //         .attr("fill", "none")
    //         .attr("stroke", "#000")
    //         .attr("stroke-width", 1.5)
    //         .attr("stroke-linejoin", "round")
    //         .attr("d", line(density));
        
    //     svg.append("g")
    //         .call(xAxis);

    //     svg.append("g")
    //         .call(yAxis);

    //     return data
    // });
    


    // function clicked() {
    //     console.log($(".rs_range")[0].value, $(".rs_range")[1].value)

    //     promise.then(function(data) {
    //         var svg = d3.select("svg") // .transition();
    //         density = kde(epanechnikov($(".rs_range")[1].value), thresholds, data)
            
    //         svg.select("#p1")
    //             .transition()
    //             .duration(750)
    //             .attr("d", line(density))
    //     });
    // }

</script>

